/**
 * generated by Xtext 2.25.0
 */
package org.xtext.coursework.storyLang.validation;

import java.util.List;
import java.util.Set;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.xtext.coursework.storyLang.story.AmountStatement;
import org.xtext.coursework.storyLang.story.MoodStatement;
import org.xtext.coursework.storyLang.story.MoveStatement;
import org.xtext.coursework.storyLang.story.NearbyStatement;
import org.xtext.coursework.storyLang.story.PathStatement;
import org.xtext.coursework.storyLang.story.PlaceStatement;
import org.xtext.coursework.storyLang.story.StoryPackage;
import org.xtext.coursework.storyLang.story.SubstanceStatement;

/**
 * This class contains custom validation rules.
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class StoryValidator extends AbstractStoryValidator {
  @Check
  public void checkAmountStatement(final AmountStatement statement) {
    int _value = statement.getValue();
    boolean _lessThan = (_value < 1);
    if (_lessThan) {
      this.warning("Amount must be a positive integer larger than zero", StoryPackage.Literals.AMOUNT_STATEMENT__VALUE);
    }
  }
  
  @Check
  public void checkPlaceStatement(final PlaceStatement placeStatement) {
    if (((placeStatement.getValue() == null) || placeStatement.getValue().trim().isEmpty())) {
      this.warning("Place name cannot be empty", placeStatement, null, null);
    }
  }
  
  @Check
  public void checkPathStatement(final PathStatement pathStatement) {
    int _size = pathStatement.getList().size();
    boolean _lessThan = (_size < 2);
    if (_lessThan) {
      this.warning("Path must have at least two elements", pathStatement, null, null);
    }
  }
  
  @Check
  public void checkMoveStatement(final MoveStatement moveStatement) {
    int _size = moveStatement.getList().size();
    boolean _lessThan = (_size < 2);
    if (_lessThan) {
      this.warning("Move list must have at least two elements", moveStatement, null, null);
    }
  }
  
  @Check
  public void checkNearbyStatement(final NearbyStatement nearbyStatement) {
    boolean _isEmpty = nearbyStatement.getList().isEmpty();
    if (_isEmpty) {
      this.warning("Nearby list cannot be empty", nearbyStatement, null, null);
    }
  }
  
  @Check
  public void checkSubstanceStatement(final SubstanceStatement substanceStatement) {
    int _size = substanceStatement.getList().size();
    boolean _lessThan = (_size < 2);
    if (_lessThan) {
      this.warning("Substance list must have at least two elements", substanceStatement, null, null);
    }
  }
  
  @Check
  public void checkMoodStatement(final MoodStatement moodStatement) {
    int _size = moodStatement.getList().size();
    boolean _lessThan = (_size < 3);
    if (_lessThan) {
      this.warning("Mood list must have at least three elements", moodStatement, null, null);
    }
  }
  
  @Check
  public void checkDuplicateItems(final PathStatement statement) {
    this.checkDuplicates(statement.getList(), "Path");
  }
  
  @Check
  public void checkDuplicateItems(final MoveStatement statement) {
    this.checkDuplicates(statement.getList(), "Move");
  }
  
  @Check
  public void checkDuplicateItems(final NearbyStatement statement) {
    this.checkDuplicates(statement.getList(), "Nearby");
  }
  
  @Check
  public void checkDuplicateItems(final SubstanceStatement statement) {
    this.checkDuplicates(statement.getList(), "Substance");
  }
  
  @Check
  public void checkDuplicateItems(final MoodStatement statement) {
    this.checkDuplicates(statement.getList(), "Mood");
  }
  
  public void checkDuplicates(final List<String> list, final String statementName) {
    final Set<String> set = IterableExtensions.<String>toSet(list);
    int _size = set.size();
    int _size_1 = list.size();
    boolean _lessThan = (_size < _size_1);
    if (_lessThan) {
      this.warning((("Duplicate items found in " + statementName) + " statement"), null);
    }
  }
  
  @Check
  public void checkAmountStatementType(final AmountStatement amountStatement) {
    boolean _matches = Integer.valueOf(amountStatement.getValue()).toString().matches("-?[0-9]+");
    boolean _not = (!_matches);
    if (_not) {
      this.warning("Amount value must be an integer", amountStatement, StoryPackage.Literals.AMOUNT_STATEMENT__VALUE);
    }
  }
  
  @Check
  public void checkPlaceStatementType(final PlaceStatement placeStatement) {
    boolean _matches = placeStatement.getValue().matches("[a-zA-Z0-9_]*");
    boolean _not = (!_matches);
    if (_not) {
      this.warning("Place value must be a string", placeStatement, StoryPackage.Literals.PLACE_STATEMENT__VALUE);
    }
  }
}
