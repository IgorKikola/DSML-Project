/**
 * generated by Xtext 2.25.0
 */
package org.xtext.coursework.storyLang.tests;

import com.google.inject.Inject;
import java.util.List;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.testing.InjectWith;
import org.eclipse.xtext.testing.extensions.InjectionExtension;
import org.eclipse.xtext.testing.util.ParseHelper;
import org.eclipse.xtext.testing.validation.ValidationTestHelper;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.junit.Assert;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.xtext.coursework.storyLang.generator.StoryGenerator;
import org.xtext.coursework.storyLang.story.AmountStatement;
import org.xtext.coursework.storyLang.story.MoveStatement;
import org.xtext.coursework.storyLang.story.NearbyStatement;
import org.xtext.coursework.storyLang.story.PathStatement;
import org.xtext.coursework.storyLang.story.PlaceStatement;
import org.xtext.coursework.storyLang.story.Statement;
import org.xtext.coursework.storyLang.story.StoryProgram;
import org.xtext.coursework.storyLang.story.SubstanceStatement;

@ExtendWith(InjectionExtension.class)
@InjectWith(StoryInjectorProvider.class)
@SuppressWarnings("all")
public class StoryDataParsingTest {
  @Inject
  private ParseHelper<StoryProgram> parseHelper = new ParseHelper<StoryProgram>();

  @Inject
  private ValidationTestHelper validationTestHelper;

  @Test
  @DisplayName("Test parsing all statements in a single program")
  public void testParsing() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("place: \"forest\";");
      _builder.newLine();
      _builder.append("path: \"river\", \"bridge\", \"mountain\";");
      _builder.newLine();
      _builder.append("move: \"run\", \"climb\", \"jump\";");
      _builder.newLine();
      _builder.append("nearby: \"waterfall\", \"cave\";");
      _builder.newLine();
      _builder.append("substance: \"moss\", \"rocks\";");
      _builder.newLine();
      _builder.append("mood: \"excited\", \"nervous\";");
      _builder.newLine();
      _builder.append("amount: 3;");
      _builder.newLine();
      final String input = _builder.toString();
      final StoryProgram program = this.parseHelper.parse(input);
      Assert.assertNotNull(program);
      Assert.assertEquals(7, program.getStatements().size());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  @DisplayName("Test correct amount of landscapes gets generated")
  public void testCorrectAmount() {
    try {
      final StoryGenerator generator = new StoryGenerator();
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("place:\"forest\";");
      _builder.newLine();
      _builder.append("move: \"spiral\", \"twirl\", \"curl\", \"dance\", \"twine\", \"weave\", \"meander\", \"wander\", \"flow\";");
      _builder.newLine();
      _builder.append("substance:\"light\", \"reflections\", \"mist\", \"shadow\", \"darkness\", \"brightness\", \"gaiety\", \"merriment\";");
      _builder.newLine();
      _builder.append("mood:\"overcast\", \"alight\", \"clear\", \"darkened\", \"blue\", \"shadowed\", \"illuminated\", \"silver\", \"cool\", \"warm\", \"summer-warmed\";");
      _builder.newLine();
      _builder.append("nearby:\"far away\", \"ahead\", \"behind me\";");
      _builder.newLine();
      _builder.append("path:\"stream\", \"brook\", \"path\", \"ravine\", \"forest\", \"fence\", \"stone wall\";");
      _builder.newLine();
      _builder.append("amount: 453;");
      _builder.newLine();
      final String input = _builder.toString();
      final StoryProgram program = this.parseHelper.parse(input);
      final String generatedCode = generator.doGenerate(program);
      final String[] lines = generatedCode.split("\n");
      final int numLines = ((List<String>)Conversions.doWrapArray(lines)).size();
      Assert.assertEquals(454, numLines);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void testAmountStatementParsing() {
    try {
      final String input = "amount: 5;";
      final StoryProgram program = this.parseHelper.parse(input);
      Assert.assertEquals(1, program.getStatements().size());
      Statement _head = IterableExtensions.<Statement>head(program.getStatements());
      Assert.assertTrue((_head instanceof AmountStatement));
      Statement _head_1 = IterableExtensions.<Statement>head(program.getStatements());
      Assert.assertEquals(5, ((AmountStatement) _head_1).getValue());
      this.validationTestHelper.assertNoErrors(program);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void testPlaceStatementParsing() {
    try {
      final String input = "place: \'forest\';";
      final StoryProgram program = this.parseHelper.parse(input);
      Assert.assertEquals(1, program.getStatements().size());
      Statement _head = IterableExtensions.<Statement>head(program.getStatements());
      Assert.assertTrue((_head instanceof PlaceStatement));
      Statement _head_1 = IterableExtensions.<Statement>head(program.getStatements());
      Assert.assertEquals("forest", ((PlaceStatement) _head_1).getValue());
      this.validationTestHelper.assertNoErrors(program);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void testPathStatementParsing() {
    try {
      final String input = "path: \'start\', \'middle\', \'end\';";
      final StoryProgram program = this.parseHelper.parse(input);
      Assert.assertEquals(1, program.getStatements().size());
      Statement _head = IterableExtensions.<Statement>head(program.getStatements());
      Assert.assertTrue((_head instanceof PathStatement));
      Statement _head_1 = IterableExtensions.<Statement>head(program.getStatements());
      Assert.assertEquals(CollectionLiterals.<String>newArrayList("start", "middle", "end"), ((PathStatement) _head_1).getList());
      this.validationTestHelper.assertNoErrors(program);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void testMoveStatementParsing() {
    try {
      final String input = "move: \'north\', \'west\', \'south\';";
      final StoryProgram program = this.parseHelper.parse(input);
      Assert.assertEquals(1, program.getStatements().size());
      Statement _head = IterableExtensions.<Statement>head(program.getStatements());
      Assert.assertTrue((_head instanceof MoveStatement));
      Statement _head_1 = IterableExtensions.<Statement>head(program.getStatements());
      Assert.assertEquals(CollectionLiterals.<String>newArrayList("north", "west", "south"), ((MoveStatement) _head_1).getList());
      this.validationTestHelper.assertNoErrors(program);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void testNearbyStatementParsing() {
    try {
      final String input = "nearby: \'tree\', \'rock\', \'stream\';";
      final StoryProgram program = this.parseHelper.parse(input);
      Assert.assertEquals(1, program.getStatements().size());
      Statement _head = IterableExtensions.<Statement>head(program.getStatements());
      Assert.assertTrue((_head instanceof NearbyStatement));
      Statement _head_1 = IterableExtensions.<Statement>head(program.getStatements());
      Assert.assertEquals(CollectionLiterals.<String>newArrayList("tree", "rock", "stream"), ((NearbyStatement) _head_1).getList());
      this.validationTestHelper.assertNoErrors(program);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void testSubstanceStatementParsing() {
    try {
      final String input = "substance: \'water\', \'wood\', \'stone\';";
      final StoryProgram program = this.parseHelper.parse(input);
      Assert.assertEquals(1, program.getStatements().size());
      Statement _head = IterableExtensions.<Statement>head(program.getStatements());
      Assert.assertTrue((_head instanceof SubstanceStatement));
      Statement _head_1 = IterableExtensions.<Statement>head(program.getStatements());
      Assert.assertEquals(CollectionLiterals.<String>newArrayList("water", "wood", "stone"), ((SubstanceStatement) _head_1).getList());
      this.validationTestHelper.assertNoErrors(program);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
}
